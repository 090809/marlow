package marlow

import "io"
import "os"
import "fmt"
import "sync"
import "bytes"
import "go/token"
import "go/parser"
import "go/format"

import "github.com/dadleyy/marlow/marlow/writing"

const (
	compilerHeader = "Code auto-generated by marlow"
)

// Compile is responsible for reading from a source and writing the generated marlow code into a destination.
func Compile(destination io.Writer, reader io.Reader) error {
	fs := token.NewFileSet()
	packageAst, e := parser.ParseFile(fs, "", reader, parser.AllErrors)

	if e != nil {
		return e
	}

	buffered, packageName := new(bytes.Buffer), packageAst.Name.String()
	importChannel, recordReaders := make(chan string), make([]io.Reader, 0, len(packageAst.Decls))

	// Iterate over the declarations and construct the record store from the loaded ast.
	for _, d := range packageAst.Decls {
		reader, ok := newRecordReader(d, importChannel)

		// Only deal with struct type declarations.
		if !ok {
			continue
		}

		recordReaders = append(recordReaders, reader)
	}

	if len(recordReaders) == 0 {
		return nil
	}

	// Write out the main package information
	packageWriter := writing.NewGoWriter(buffered)
	packageWriter.Comment(compilerHeader)
	packageWriter.Println("")
	packageWriter.WritePackage(packageName)

	wg := &sync.WaitGroup{}

	// In a separate goroutine, iterate over all the received import names, adding them to the buffered output.
	go func() {
		wg.Add(1)
		importList := make(map[string]bool)

		for importName := range importChannel {
			if _, dupe := importList[importName]; dupe == true {
				continue
			}

			importList[importName] = true
			packageWriter.WriteImport(importName)
		}

		wg.Done()
	}()

	// Prepare the intermediate buffer that will be used to write each of the generated api.
	records := new(bytes.Buffer)

	// Copy all of the table readers into our temporary table buffer.
	if _, e := io.Copy(records, io.MultiReader(recordReaders...)); e != nil {
		return e
	}

	// Close the import writer, and wait for it to finish.
	close(importChannel)
	wg.Wait()

	// Copy the generated table constructs into the final buffer.
	if _, e := io.Copy(buffered, records); e != nil {
		return e
	}

	formatted, e := format.Source(buffered.Bytes())

	if e != nil {
		return fmt.Errorf("%s: (%s)", e.Error(), buffered.String())
	}

	_, e = io.Copy(destination, bytes.NewBuffer(formatted))

	return e
}

// NewReaderFromFile opens the requested filename and returns an io.Reader that represents the compiled source.
func NewReaderFromFile(filename string) (io.Reader, error) {
	source, e := os.Open(filename)

	if e != nil {
		return nil, e
	}

	pr, pw := io.Pipe()

	go func() {
		defer source.Close()

		if e := Compile(pw, source); e != nil {
			pw.CloseWithError(e)
			return
		}

		pw.Close()
	}()

	return pr, nil
}
